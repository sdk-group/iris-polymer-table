<link rel="import" href="../../bower_components/polymer/polymer.html">

<link rel="import" href="etable-cell.html">
<link rel="import" href="etable-cell-register.html">
<link rel="import" href="base-templates.html">

<dom-module id="iris-table">
  <template>
    <style>
      :host {
        display: block;
        overflow: auto;
        --paper-checkbox-size: 16px;
      }

      .checkbox {
        width: 30px;
      }

      #entity-table td {
        white-space: nowrap;
      }

      #entity-table td:first-of-type {
        @apply(--iris-table-first-cal);
      }

      tr {
        border-bottom: 1px solid;
        border-color: var(--mydoc-black-200);
        color: var(--mydoc-black-800);
        height: 48px;
      }

      td,
      th {
        padding: 0 12px;
      }

      th etable-cell,
      td etable-cell {
        @apply(--iris-table-cell);
      }

      tr td {
        font-size: 13px;
      }

      tr th {
        color: var(--mydoc-black-600);
        height: 56px;
        font-size: 12px;
      }

      table {
        width: 100%;
        text-align: center;
        border-collapse: collapse;
      }

      tbody tr:last-of-type {
        border-bottom: none;
      }

      thead.fixed {
        background-color: #fafafa;
      }

      thead.fixed tr {
        border-bottom: none;
      }

      #border-fix th {
        height: 1px;
      }

      #border-fix {
        height: 1px;
        background-color: var(--mydoc-black-200);
      }
    </style>


    <table id="entity-table">
      <thead class$="[[headClass(fixedHeader)]]">
        <tr>
          <template is="dom-if" if="[[multiselect]]">
            <th class="checkbox">
              <paper-checkbox checked="[[isAllSelected(selectedIndex.length,data)]]" id="select-all" on-change="pickAll"></paper-checkbox>
            </th>
          </template>
          <template id="row" is="dom-repeat" items="[[computedModel]]" as="model">
            <th>
              [[model.label]]
            </th>
          </template>
        </tr>

        <template is="dom-if" if="[[hasSummary]]">
          <tr>
            <template id="row" is="dom-repeat" items="[[computedModel]]" as="model">
              <th>
                <etable-cell is-editable="[[isEditable]]" data="[[getSummary(model,data)]]" model="[[getSummaryModel(model)]]" on-tap="summaryTap"></etable-cell>
              </th>
            </template>
          </tr>
        </template>

        <template is="dom-if" if="[[fixedHeader]]">
          <tr id="border-fix">
            <template id="row" is="dom-repeat" items="[[computedModel]]" as="model">
              <th> </th>
            </template>
          </tr>
        </template>
      </thead>

      <template id="table" is="dom-repeat" items="[[data]]" as="row" index-as="rowIndex">
        <tr>
          <template is="dom-if" if="[[multiselect]]">
            <td class="checkbox">
              <paper-checkbox checked="[[isSelected(rowIndex,selectedIndex.length)]]" on-change="toggleSelection"></paper-checkbox>
            </td>
          </template>
          <template id="row" is="dom-repeat" items="[[computedModel]]" as="model">
            <td>
              <etable-cell is-editable="[[isEditable]]" data="[[getCelldata(model,row)]]" model="[[model]]" on-tap="cellTap" rowIndex="[[rowIndex]]"></etable-cell>
            </td>
          </template>
        </tr>
      </template>
    </table>

  </template>
  <script>
    'use strict'

    Polymer({
      is: 'iris-table',
      listeners: {
        'scroll': 'onTableScroll'
      },
      properties: {
        fieldsModel: {
          type: Object
        },
        computedModel: {
          type: Array,
          computed: '_computeFields(fieldsModel)'
        },
        multiselect: {
          type: Boolean,
          value: false
        },
        isEditable: {
          type: Boolean,
          value: false
        },
        selected: {
          type: Array,
          value: [],
          notify: true
        },
        selectionField: String,
        selectedIndex: {
          type: Array,
          value: [],
          notify: true
        },
        fixedHeader: {
          type: Boolean,
          value: false
        },
        hasSummary: {
          type: Boolean,
          value: false
        },
        data: Object
      },
      cellTap(e) {
        let data = e.model;

        this.fire('cell-tap', {
          row: data.rowIndex,
          col: data.index,
          model: data.model
        });
      },
      summaryTap(e) {
        let data = e.model;

        this.fire('summary-tap', {
          col: data.index,
          model: data.model
        });
      },
      onTableScroll() {
        if (!this.fixedHeader) return;
        var translate = "translate(0," + this.scrollTop + "px)";
        this.querySelector("thead").style.transform = translate;
      },
      headClass(f) {
        return f ? 'fixed' : 'free';
      },
      _computeFields(fieldsModel) {
        return _.isArray(fieldsModel) ? fieldsModel : _.map(fieldsModel, (label, field) => ({
          field,
          label
        }));
      },
      isAllSelected(len) {
        return this.data.length == len;
      },
      isSelected(index, selected) {
        return !!~this.selectedIndex.indexOf(index);
      },
      pickAll(e) {
        if (e.target.checked) {
          let keys = _.keys(this.data);
          this.set('selectedIndex', _.map(keys, k => parseInt(k)));
          this.set('selected', this.selectionField ? _.map(this.data, this.selectionField) : this.data)

          return;
        }
        this.set('selected', []);
        this.set('selectedIndex', []);
        this.notifyPath('selected.length', 0);
        this.notifyPath('selectedIndex.length', 0);
      },
      getCelldata(model, row) {
        if (_.isArray(model.fields)) return _.pick(row, model.fields);
        if (_.isObject(model.fields)) return _.reduce(model.fields, (accum, row_key, transform_key) => {
          //@NOTE: r as key
          accum[transform_key] = row[row_key]
          return accum;
        }, {});

        if (!model.field) return undefined
        return _.get(row, model.field);
      },
      toggleSelection(e) {
        var index = e.model.rowIndex;
        var item = this.$.table.itemForElement(e.target);
        if (!e.target.checked) {
          this.arrayDelete('selectedIndex', index);
          this.arrayDelete('selected', this.selectionField ? this.data[index][this.selectionField] : this.data[index]);
        } else {
          this.push('selectedIndex', index);
          this.push('selected', this.selectionField ? this.data[index][this.selectionField] : this.data[index]);
        }
      },
      ready() {
        this.counter = 0;
      },
      getSummary(model, data) {
        let reducer = model.reducer;

        if (!_.isFunction(reducer)) return reducer;

        let field = model.field;
        let initial = _.clone(model.initial) || 0;
        let cells = _.map(data, (row) => this.getCelldata(model, row));
        let result = _.reduce(cells, reducer, initial);

        return result;
      },
      getSummaryModel(model) {
        return {
          template: model.summary || false
        }
      }
    });
  </script>
</dom-module>
